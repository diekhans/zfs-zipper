#!/usr/bin/env python3
"""ZFS-based backup driver with rotating backup sets.

A BackupSet consists of BackupPools, for backing up the same set of source
data and can be rotated.  A BackupPool could be a single disk or a RAID pool.

The source file system structure is reproduced under the top level BackupPool
file system. Snapshots of the source file systems are use to manage the backup
on the BackupPool file systems.  The first back is conceptually a `full'
backup, but this could start at any snapshot.  Subsequent backups are sent
as deltas between snapshots.

Snapshots are named in the form:
    zipper_<GMT>_<backupset>

Older versions names snapshots in the forms:
    zipper_<GMT>_<backupset>_full
    zipper_<GMT>_<backupset>_incr
However, the concept of full vs increment wasn't useful and these extensions
are now just part of the name and not added for new snapshots.  It the future,
other suffixes might be used as some kind of taggins system.

When a backup is started, a new snapshot is made on the source file system.
Incremental snapshots are sent to the backup file system starting after
the most recent common snapshot to the new source snapshot.

If there are not zfs-zipper snapshots on the backup file system,
all snapshots are copied.  If there are zfs-zipper snapshots, but
no common ones, it is currently an error.

Other features maybe added in the future to adjust starting snapshot
to allow for omitting deleted data.

"""

import os
import sys
import argparse
import fcntl
import logging
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.insert(0, os.path.join(myBinDir, "../lib/zfs-zipper"))
from zfszipper.zfs import Zfs
from zfszipper.backup import BackupSetBackup, BackupRecorder, BackupError
from zfszipper.config import BackupConf
from zfszipper import loggingOps
from zfszipper.cmdrunner import stdflush
logger = logging.getLogger()

defaultConfig = os.path.join(myBinDir, "../etc/zfs-zipper.conf.py")

def evalConfigFile(configPyFile):
    "evaluate file and return BackupConf object"
    configEnv = {}
    with open(configPyFile) as fh:
        exec(fh.read(), configEnv, configEnv)
    config = configEnv.get("config")
    if config is None:
        raise Exception("config file {} doesn't set variable 'config'".format(configPyFile,))
    if not isinstance(config, BackupConf):
        raise Exception("config file {} variable 'config' isn't an instance of BackupConf, found".format(configPyFile, str(type(config))))
    return config

def parseCommand():
    usage = """Run a backup from ZFS source pools to back source pools.
    """
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument("configPy", default=defaultConfig, nargs='?',
                        help="""Configuration file written in Python.  It should do a `from zfszipper.config import *'
                        and then create an instance of BackupConf() stored in a module-global variable `config'.""")
    parser.add_argument("--backupSet", metavar="name", dest="backupSetName",
                        help="""Backup only this set.  If not specified, all sets in config file are backed up.""")
    parser.add_argument("--sourceFileSystem", metavar="name", dest="sourceFileSystemNames", action="append",
                        help="""Backup only this ZFS file system (not mount point).   Must specify --backUpSet. This option maybe repeated.""")
    # parser.add_argument("--baseSnapshot", dest="baseSnapshots", metavar="fs@snapshot", action="append",
    #                     help="""If specified, this is the existing snapshot on the source file
    #                     system where the backup should begin.   The snapshot must not exists of the backup.
    #                     This maybe repeated for multiple file systems. This will disable default backups,
    #                     to prevent errors. [NOT IMPLEMENTED}""")
    parser.add_argument("--verboseLevel", metavar="logLevel", dest="verboseLevel", action="store", default="error",
                        help="""syslog style level name for logging to stderr""")
    args = parser.parse_args()
    setattr(args, "config", evalConfigFile(args.configPy))
    if args.verboseLevel is not None:
        args.verboseLevel = loggingOps.parseLevel(args.verboseLevel)
    if args.sourceFileSystemNames is not None:
        args.sourceFileSystemNames = [os.path.normpath(fs) for fs in args.sourceFileSystemNames]
    # if args.baseSnapshots is not None:
    #     parser.error("--naseSnapshot is not yet implemented")
    #     args.baseSnapshots = [BackupSnapshot.createFromSnapshotName(fb, requireFileSystem=True) for fb in args.baseSnapshots]
    #     checkDupBaseSnapshots(parser, args.baseSnapshots)
    checkBackupSubsetArgs(parser, args)
    return args

def checkDupBaseSnapshots(parser, baseSnapshots):
    # NOT CURRENTLY USED OR TESTED
    found = set()
    for baseSnapshot in baseSnapshots:
        if baseSnapshot.fileSystemName in found:
            parser.error("file system {} from specified in multiple --baseSnapshot arguments".format(baseSnapshot.fileSystemName, baseSnapshot))
        found.add(baseSnapshot.fileSystemName)

def checkBackupSubsetArgs(parser, args):
    if (args.sourceFileSystemNames is not None) and (args.backupSetName is None):
        parser.error("must specify --backUpSet with --sourceFileSystemName")
    if args.backupSetName is not None:
        backupSetConf = args.config.getBackupSet(args.backupSetName)  # error if not found
        if args.sourceFileSystemNames is not None:
            for sourceFileSystemName in args.sourceFileSystemNames:
                backupSetConf.getSourceFileSystem(sourceFileSystemName)  # error if not found

class Backup(object):
    "controls overall backup from args"
    def __init__(self, args):
        self.config = args.config
        self.recorder = BackupRecorder(self.config.recordFile, sys.stdout)
        self.zfs = Zfs()
        self.backupSetName = args.backupSetName
        self.sourceFileSystemNames = tuple(args.sourceFileSystemNames) if args.sourceFileSystemNames is not None else None
        # FIXME self.baseSnapshotMap = self._partitionBaseSnapshots(args.baseSnapshots)
        self.lockFh = None

    def _getActiveBackupSets(self):
        if self.backupSetName is not None:
            return (self.config.getBackupSet(self.backupSetName),)
        else:
            return self.config.backupSets

    def _partitionBaseSnapshot(self, baseSnapshot, fsBaseSnapshotMap):
        "Add mapping of fs name to baseSnapshot.  Check that FS is in one and only one of the backsets"
        # NOT CURRENTLY USED OR TESTED
        if (self.sourceFileSystemNames is not None) and (baseSnapshot.fileSystemName not in self.sourceFileSystemNames):
            raise Exception("file system {} from baseSnapshot {} not in restricted set of file systems {}"
                            .format(baseSnapshot.fileSystemName, baseSnapshot, self.sourceFileSystemNames))

        baseSnapshotMap = {}
        for backupSetConf in self._getActiveBackupSets():
            fs = backupSetConf.findSourceFileSystem(baseSnapshot.fileSystemName)
            if fs is not None:
                if fs.fileSystemName in baseSnapshotMap:
                    raise Exception("file system {} from baseSnapshot {} found in multiple backupsets, must restrict to one backup set to use this feature"
                                    .format(baseSnapshot.fileSystemName, baseSnapshot))
                baseSnapshotMap[baseSnapshot.fileSystemName] = baseSnapshot
        if baseSnapshot.fileSystemName not in baseSnapshotMap:
            raise Exception("file system {} from baseSnapshot {} found in any of the backupset or the one configured on the command line"
                            .format(baseSnapshot.fileSystemName, baseSnapshot))

    def _partitionBaseSnapshots(self, baseSnapshots):
        """partition list of bases snapshots by file system and ensure both
        file system and snapshot exist."""
        # NOT CURRENTLY USED OR TESTED
        baseSnapshotMap = {}
        if baseSnapshots is not None:
            for baseSnapshot in baseSnapshots:
                self._partitionBaseSnapshot(baseSnapshot, baseSnapshotMap)
        return baseSnapshotMap

    def __obtainLock(self):
        self.lockFh = open(self.config.lockFile, "w")
        try:
            fcntl.lockf(self.lockFh, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError as ex:
            raise BackupError("can't lock {}, is another backup running?".format(self.config.lockFile), ex)

    def _backupOneSet(self, backupSetConf, sourceFileSystemNames=None):
        backupper = BackupSetBackup(self.zfs, self.recorder, backupSetConf)
        sourceFileSystemConfs = None
        if sourceFileSystemNames is not None:
            sourceFileSystemConfs = [backupSetConf.getSourceFileSystem(n) for n in sourceFileSystemNames]
        backupper.backup(sourceFileSystemConfs)

    def runBackups(self):
        self.__obtainLock()
        for backupSetConf in self._getActiveBackupSets():
            self._backupOneSet(backupSetConf, self.sourceFileSystemNames)

def main(args):
    if args.verboseLevel is not None:
        loggingOps.setupStderrLogger(args.verboseLevel)
    if args.config.syslogFacility is not None:
        loggingOps.setupSyslogLogger(args.config.syslogFacility, args.config.syslogLevel, prog=os.path.basename(sys.argv[0]))
    if (args.verboseLevel is None) and (args.config.syslogFacility is None):
        loggingOps.setupNullLogger()

    backup = Backup(args)
    try:
        backup.runBackups()
    except Exception as ex:
        stdflush()
        logger.exception("zfs-zipper backup of failed")
        sys.stderr.write("error: " + str(ex) + " (specify --verboseLevel=error for more details)\n")
        sys.exit(1)

    logger.info("zfs-zipper backup of complete")

main(parseCommand())
