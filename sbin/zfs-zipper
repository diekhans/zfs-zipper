#!/usr/bin/env python3
"""ZFS-based backup driver with rotating backup sets.

A BackupSet consists of BackupPools, for backing up the same set of source
data and can be rotated.  A BackupPool could be a single disk or a RAID pool.

The source file system structure is reproduced under the top level BackupPool
file system. Snapshots of the source file systems are use to manage the backup
on the BackupPool file systems.  The first back is conceptually a `full'
backup, but this could start at any snapshot.  Subsequent backups are sent
as deltas between snapshots.

Snapshots are named in the form:
    zipper_<GMT>_<backupset>

Older versions names snapshots in the forms:
    zipper_<GMT>_<backupset>_full
    zipper_<GMT>_<backupset>_incr
However, the concept of full vs increment wasn't useful and these extensions
are now just part of the name and not added for new snapshots.  It the future,
other suffixes might be used as some kind of tagging system.

When a backup is started, a new snapshot is made on the source file system.
Incremental snapshots are sent to the backup file system starting after
the most recent common snapshot to the new source snapshot.

If there are not zfs-zipper snapshots on the backup file system,
all snapshots are copied.  If there are zfs-zipper snapshots, but
no common ones, it is currently an error.

This has also been used to clone all backups to a new file system.

Other features maybe added in the future to adjust starting snapshot
to allow for omitting deleted data.

"""

import os
import sys
import argparse
import fcntl
import logging
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.insert(0, os.path.join(myBinDir, "../lib/zfs-zipper"))
from zfszipper.zfs import Zfs
from zfszipper.backup import BackupSetBackup, BackupRecorder, BackupError
from zfszipper.config import BackupConf
from zfszipper import loggingOps
from zfszipper.cmdrunner import stdflush
logger = logging.getLogger()

defaultConfig = os.path.join(myBinDir, "../etc/zfs-zipper.conf.py")

def evalConfigFile(configPyFile):
    "evaluate file and return BackupConf object"
    configEnv = {}
    with open(configPyFile) as fh:
        exec(fh.read(), configEnv, configEnv)
    config = configEnv.get("config")
    if config is None:
        raise Exception("config file {} doesn't set variable 'config'".format(configPyFile,))
    if not isinstance(config, BackupConf):
        raise Exception("config file {} variable 'config' isn't an instance of BackupConf, found: {}".format(configPyFile, str(type(config))))
    return config

def parseCommand():
    usage = """Run a backup from ZFS source pools to back source pools.
    """
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument("--list", "-l", dest="listSets", action="store_true", default=False,
                        help="""List backup sets""")
    parser.add_argument("--conf", default=defaultConfig, dest="configPy",
                        help="""Configuration file written in Python.  It should do a `from zfszipper.config import *'
                        and then create an instance of BackupConf() stored in a module-global variable `config'.""")
    parser.add_argument("--sourceFileSystem", metavar="name", dest="sourceFileSystemNames", action="append",
                        help="""Backup only this ZFS file system (not mount point).   Must specify --backupSet. This option maybe repeated.""")
    parser.add_argument("--verboseLevel", metavar="logLevel", dest="verboseLevel", action="store", default="info",
                        help="""syslog style level name for logging to stderr""")
    parser.add_argument("--snapOnly", dest="snapOnly", action="store_true", default=False,
                        help="""Only create source snapshots don't backup to disk.  They will be backed up on the next real backup.""")
    parser.add_argument("--allowDegraded", dest="allowDegraded", action="store_true", default=False,
                        help="""Allow backup to a degraded pool""")
    parser.add_argument("backupSetNames", metavar="backupSetName", default=[], nargs='*',
                        help="""Backup only these sets.  If not specified, all sets in config file are backed up.""")
    args = parser.parse_args()
    setattr(args, "config", evalConfigFile(args.configPy))
    if args.verboseLevel is not None:
        args.verboseLevel = loggingOps.parseLevel(args.verboseLevel)
    if args.sourceFileSystemNames is not None:
        args.sourceFileSystemNames = [os.path.normpath(fs) for fs in args.sourceFileSystemNames]
    checkBackupSubsetArgs(parser, args)
    return args

def checkBackupSubsetArgs(parser, args):
    if (args.sourceFileSystemNames is not None) and (len(args.backupSetNames) != 1):
        parser.error("must specify a single backUpSet with --sourceFileSystemName")
    for backupSetName in args.backupSetNames:
        backupSetConf = args.config.getBackupSet(backupSetName)  # error if not found
    if args.sourceFileSystemNames is not None:
        for sourceFileSystemName in args.sourceFileSystemNames:
            backupSetConf.getSourceFileSystem(sourceFileSystemName)  # error if not found

class Backup(object):
    "controls overall backup from args"
    def __init__(self, config, backupSetNames, sourceFileSystemNames, snapOnly, allowDegraded):
        self.config = config
        self.recorder = None if snapOnly else BackupRecorder(self.config.recordFile, sys.stdout)
        self.zfs = Zfs()
        self.backupSetNames = backupSetNames
        self.sourceFileSystemNames = tuple(sourceFileSystemNames) if sourceFileSystemNames is not None else None
        self.snapOnly = snapOnly
        self.allowDegraded = allowDegraded
        self.lockFh = None

    def _getActiveBackupSets(self):
        if len(self.backupSetNames) > 0:
            return [self.config.getBackupSet(bs) for bs in self.backupSetNames]
        else:
            return self.config.backupSets

    def __obtainLock(self):
        self.lockFh = open(self.config.lockFile, "w")
        try:
            fcntl.lockf(self.lockFh, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError as ex:
            raise BackupError("can't lock {}, is another backup running?".format(self.config.lockFile), ex)

    def _backupOneSet(self, backupSetConf, sourceFileSystemNames=None):
        backupper = BackupSetBackup(self.zfs, self.recorder, backupSetConf, self.allowDegraded)
        sourceFileSystemConfs = None
        if sourceFileSystemNames is not None:
            sourceFileSystemConfs = [backupSetConf.getSourceFileSystem(n) for n in sourceFileSystemNames]
        if self.snapOnly:
            backupper.snapOnly(sourceFileSystemConfs)
        else:
            backupper.backup(sourceFileSystemConfs)

    def runBackups(self):
        self.__obtainLock()
        for backupSetConf in self._getActiveBackupSets():
            self._backupOneSet(backupSetConf, self.sourceFileSystemNames)

def setupLogging(args):
    someLogging = False
    if args.config.syslogFacility is not None:
        loggingOps.setupSyslogLogger(args.config.syslogFacility, args.config.syslogLevel, prog=os.path.basename(sys.argv[0]))
        someLogging = True
    if args.verboseLevel is not None:
        loggingOps.setupStderrLogger(args.verboseLevel)
        someLogging = True
    # if no logging is explicitly setup, we need to send messages somewhere
    if not someLogging:
        loggingOps.setupStderrLogger(logging.ERROR if args.verboseLevel is None else args.verboseLevel)

def doBackup(args):
    setupLogging(args)
    backup = Backup(args.config, args.backupSetNames, args.sourceFileSystemNames, args.snapOnly, args.allowDegraded)
    try:
        backup.runBackups()
    except Exception as ex:
        stdflush()
        logger.exception("zfs-zipper backup of failed")
        sys.stderr.write("error: " + str(ex) + " (specify --verboseLevel=debug for more details)\n")
        sys.exit(1)

    logger.info("zfs-zipper backup of complete")

def main(args):
    if args.listSets:
        args.config.listBackupSets(sys.stdout)
    else:
        doBackup(args)


main(parseCommand())
