#!/usr/bin/env python3
"""ZFS-based backup driver with rotating backup sets.

A BackupSet consists of BackupPools, for backing up the same set of source
data and can be rotated.  A BackupPool could be a single disk or a RAID pool.

The source file system structure is reproduced under the top level BackupPool
file system. Snapshots of the source file systems are use to manage the backup
on the BackupPool file systems.  The first back is conceptually a `full'
backup, but this could start at any snapshot.  Subsequent backups are sent
as deltas between snapshots.

Snapshots are named in the form:
    zipper_<GMT>_<backupset>

Older versions names snapshots in the forms:
    zipper_<GMT>_<backupset>_full
    zipper_<GMT>_<backupset>_incr
However, the concept of full vs increment wasn't useful and these extensions
are now just part of the name and not added for new snapshots.  It the future,
other suffixes might be used as some kind of taggins system.

When a backup is started, a new snapshot is made on the source file system.
Incremental snapshots are sent to the backup file system starting after
the most recent common snapshot to the new source snapshot.

If there are not zfs-zipper snapshots on the backup file system,
all snapshots are copied.  If there are zfs-zipper snapshots, but
no common ones, it is currently an error.

Other features maybe added in the future to adjust starting snapshot
to allow for omitting deleted data.

"""

import os
import sys
import argparse
import fcntl
import logging
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.insert(0, os.path.join(myBinDir, "../lib/zfs-zipper"))
from zfszipper.zfs import Zfs
from zfszipper.backup import BackupSetBackup, BackupRecorder, BackupError
from zfszipper.config import BackupConf
from zfszipper import loggingOps
from zfszipper.cmdrunner import stdflush
logger = logging.getLogger()

defaultConfig = os.path.join(myBinDir, "../etc/zfs-zipper.conf.py")

def evalConfigFile(configPyFile):
    "evaluate file and return BackupConf object"
    configEnv = {}
    with open(configPyFile) as fh:
        exec(fh.read(), configEnv, configEnv)
    config = configEnv.get("config")
    if config is None:
        raise Exception("config file {} doesn't set variable 'config'".format(configPyFile,))
    if not isinstance(config, BackupConf):
        raise Exception("config file {} variable 'config' isn't an instance of BackupConf, found".format(configPyFile, str(type(config))))
    return config

def parseCommand():
    usage = """Run a backup from ZFS source pools to back source pools.
    """
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument("configPy", default=defaultConfig, nargs='?',
                        help="""Configuration file written in Python.  It should do a `from zfszipper.config import *'
                        and then create an instance of BackupConf() stored in a module-global variable `config'.""")
    parser.add_argument("--sourceFileSystem", metavar="name", dest="sourceFileSystemNames", action="append",
                        help="""Backup only this ZFS file system (not mount point).   Must specify --backupSet. This option maybe repeated.""")
    parser.add_argument("--verboseLevel", metavar="logLevel", dest="verboseLevel", action="store", default="error",
                        help="""syslog style level name for logging to stderr""")
    parser.add_argument("backupSetName", default=None,
                        help="""Backup only this set.  If not specified, all sets in config file are backed up.""")
    args = parser.parse_args()
    setattr(args, "config", evalConfigFile(args.configPy))
    if args.verboseLevel is not None:
        args.verboseLevel = loggingOps.parseLevel(args.verboseLevel)
    if args.sourceFileSystemNames is not None:
        args.sourceFileSystemNames = [os.path.normpath(fs) for fs in args.sourceFileSystemNames]
    checkBackupSubsetArgs(parser, args)
    return args

def checkBackupSubsetArgs(parser, args):
    if (args.sourceFileSystemNames is not None) and (args.backupSetName is None):
        parser.error("must specify --backUpSet with --sourceFileSystemName")
    if args.backupSetName is not None:
        backupSetConf = args.config.getBackupSet(args.backupSetName)  # error if not found
        if args.sourceFileSystemNames is not None:
            for sourceFileSystemName in args.sourceFileSystemNames:
                backupSetConf.getSourceFileSystem(sourceFileSystemName)  # error if not found

class Backup(object):
    "controls overall backup from args"
    def __init__(self, args):
        self.config = args.config
        self.recorder = BackupRecorder(self.config.recordFile, sys.stdout)
        self.zfs = Zfs()
        self.backupSetName = args.backupSetName
        self.sourceFileSystemNames = tuple(args.sourceFileSystemNames) if args.sourceFileSystemNames is not None else None
        self.lockFh = None

    def _getActiveBackupSets(self):
        if self.backupSetName is not None:
            return (self.config.getBackupSet(self.backupSetName),)
        else:
            return self.config.backupSets

    def __obtainLock(self):
        self.lockFh = open(self.config.lockFile, "w")
        try:
            fcntl.lockf(self.lockFh, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError as ex:
            raise BackupError("can't lock {}, is another backup running?".format(self.config.lockFile), ex)

    def _backupOneSet(self, backupSetConf, sourceFileSystemNames=None):
        backupper = BackupSetBackup(self.zfs, self.recorder, backupSetConf)
        sourceFileSystemConfs = None
        if sourceFileSystemNames is not None:
            sourceFileSystemConfs = [backupSetConf.getSourceFileSystem(n) for n in sourceFileSystemNames]
        backupper.backup(sourceFileSystemConfs)

    def runBackups(self):
        self.__obtainLock()
        for backupSetConf in self._getActiveBackupSets():
            self._backupOneSet(backupSetConf, self.sourceFileSystemNames)

def main(args):
    someLogging = False
    if args.config.syslogFacility is not None:
        loggingOps.setupSyslogLogger(args.config.syslogFacility, args.config.syslogLevel, prog=os.path.basename(sys.argv[0]))
        someLogging = True
    if args.verboseLevel is not None:
        loggingOps.setupStderrLogger(args.verboseLevel)
        someLogging = True
    # if no logging is explicitly setup, we need to send messages somewhere
    if not someLogging:
        loggingOps.setupStderrLogger(logging.ERROR if args.verboseLevel is None else args.verboseLevel)

    backup = Backup(args)
    try:
        backup.runBackups()
    except Exception as ex:
        stdflush()
        logger.exception("zfs-zipper backup of failed")
        sys.stderr.write("error: " + str(ex) + " (specify --verboseLevel=error for more details)\n")
        sys.exit(1)

    logger.info("zfs-zipper backup of complete")

main(parseCommand())
